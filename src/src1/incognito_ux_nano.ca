/*****************************************************************************
 *   Ledger Monero App.
 *   (c) 2017-2020 Cedric Mesnil <cslashm@gmail.com>, Ledger SAS.
 *   (c) 2020 Ledger SAS.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *****************************************************************************/

 // #if defined(UI_NANO_X) || defined(UI_NANO_SX)

#include "os.h"
#include "cx.h"
#include "incognito_types.h"
#include "incognito_api.h"
#include "incognito_vars.h"

#include "incognito_ux_msg.h"
#include "os_io_seproxyhal.h"
#include "string.h"
#include "glyphs.h"

/* ----------------------------------------------------------------------- */
/* ---                        NanoX  UI layout                         --- */
/* ----------------------------------------------------------------------- */

#define ACCEPT 0xACCE
#define REJECT ~ACCEPT

void ui_menu_main_display(unsigned int value);

/* -------------------------------------- LOCK--------------------------------------- */

void ui_menu_pinlock_display() {
    struct {
        bolos_ux_t ux_id;
        // length of parameters in the u union to be copied during the syscall
        unsigned int len;
        union {
            struct {
                unsigned int cancellable;
            } validate_pin;
        } u;

    } ux_params;

    os_global_pin_invalidate();
    G_incognito_vstate.protocol_barrier = PROTOCOL_LOCKED_UNLOCKABLE;
    ux_params.ux_id = BOLOS_UX_VALIDATE_PIN;
    ux_params.len = sizeof(ux_params.u.validate_pin);
    ux_params.u.validate_pin.cancellable = 0;
    os_ux((bolos_ux_params_t*)&ux_params);
    ui_menu_main_display(0);
}

/* -------------------------------- INFO UX --------------------------------- */
unsigned int ui_menu_info_action(unsigned int value);

UX_STEP_CB(ux_menu_info_1_step, nn, ui_menu_info_action(0),
    {
        G_incognito_vstate.ux_info1,
        G_incognito_vstate.ux_info2,
    });

UX_FLOW(ux_flow_info, &ux_menu_info_1_step);

unsigned int ui_menu_info_action(unsigned int value) {
    if (G_incognito_vstate.protocol_barrier == PROTOCOL_LOCKED) {
        ui_menu_pinlock_display();
    }
    else {
        ui_menu_main_display(0);
    }
    return 0;
}

void ui_menu_info_display2(unsigned int value, char* line1, char* line2) {
    snprintf(G_incognito_vstate.ux_info1, sizeof(G_incognito_vstate.ux_info1), "%s", line1);
    snprintf(G_incognito_vstate.ux_info2, sizeof(G_incognito_vstate.ux_info2), "%s", line2);
    ux_flow_init(0, ux_flow_info, NULL);
}

void ui_menu_info_display(unsigned int value) { ux_flow_init(0, ux_flow_info, NULL); }

/* -------------------------------- EXPORT VIEW KEY UX --------------------------------- */
unsigned int ui_menu_export_viewkey_action(unsigned int value);

UX_STEP_NOCB(ux_menu_export_viewkey_1_step, nn, { "Export", "View Key" });

UX_STEP_CB(ux_menu_export_viewkey_2_step, pb, ui_menu_export_viewkey_action(ACCEPT),
    { &C_icon_validate_14, "Accept" });

UX_STEP_CB(ux_menu_export_viewkey_3_step, pb, ui_menu_export_viewkey_action(REJECT),
    { &C_icon_crossmark, "Reject" });

UX_FLOW(ux_flow_export_viewkey, &ux_menu_export_viewkey_1_step, &ux_menu_export_viewkey_2_step,
    &ux_menu_export_viewkey_3_step);

void ui_export_viewkey_display(unsigned int value) {
    ux_flow_init(0, ux_flow_export_viewkey, NULL);
}

unsigned int ui_menu_export_viewkey_action(unsigned int value) {
    unsigned int sw;
    unsigned char x[32];

    incognito_io_discard(0);
    os_memset(x, 0, 32);
    sw = SW_OK;

    if (value == ACCEPT) {
        incognito_io_insert(G_incognito_vstate.a, 32);
        G_incognito_vstate.export_view_key = EXPORT_VIEW_KEY;
    }
    else {
        incognito_io_insert(x, 32);
        G_incognito_vstate.export_view_key = 0;
    }
    incognito_io_insert_u16(sw);
    incognito_io_do(IO_RETURN_AFTER_TX);
    ui_menu_main_display(0);
    return 0;
}

/* -------------------------------- ACCOUNT UX --------------------------------- */

const char* const account_submenu_getter_values[] = { "0", "1", "2", "3", "4",    "5",
                                                     "6", "7", "8", "9", "Abort" };
const char* const account_submenu_getter_values_selected[] = {
    "0 +", "1 +", "2 +", "3 +", "4 +", "5 +", "6 +", "7 +", "8 +", "9 +", "Abort" };

const char* account_submenu_getter(unsigned int idx) {
    if (idx >= ARRAYLEN(account_submenu_getter_values)) {
        return NULL;
    }
    if (N_incognito_pstate->account_id == idx) {
        return account_submenu_getter_values_selected[idx];
    }
    else {
        return account_submenu_getter_values[idx];
    }
}

void account_back(void) { ui_menu_main_display(0); }

void account_submenu_selector(unsigned int idx) {
    if (idx <= 9) {
        incognito_nvm_write((void*)&N_incognito_pstate->account_id, &idx, sizeof(unsigned int));
        incognito_init();
    }
    ui_menu_main_display(0);
}

void ui_menu_account_display(unsigned int value) {
    ux_menulist_init(G_ux.stack_count - 1, account_submenu_getter, account_submenu_selector);
}

void settings_change_account(void) { ui_menu_account_display(0); }
/* -------------------------------- RESET UX --------------------------------- */
void ui_menu_reset_display(unsigned int value);
void ui_menu_reset_action(unsigned int value);

UX_STEP_NOCB(ux_menu_reset_1_step, nn,
    {
        "",
        "Really Reset?",
    });

UX_STEP_CB(ux_menu_reset_2_step, pb, ui_menu_reset_action(REJECT),
    {
        &C_icon_crossmark,
        "No",
    });

UX_STEP_CB(ux_menu_reset_3_step, pb, ui_menu_reset_action(ACCEPT),
    {
        &C_icon_validate_14,
        "Yes",
    });

UX_FLOW(ux_flow_reset, &ux_menu_reset_1_step, &ux_menu_reset_2_step, &ux_menu_reset_3_step);

void ui_menu_reset_display(unsigned int value) { ux_flow_init(0, ux_flow_reset, 0); }

void settings_reset(void) { ui_menu_reset_display(0); }

void ui_menu_reset_action(unsigned int value) {
    if (value == ACCEPT) {
        unsigned char magic[4];
        magic[0] = 0;
        magic[1] = 0;
        magic[2] = 0;
        magic[3] = 0;
        incognito_nvm_write((void*)N_incognito_pstate->magic, magic, 4);
        incognito_init();
    }
    ui_menu_main_display(0);
}
/* ------------------------------- SETTINGS UX ------------------------------- */

const char* const settings_submenu_getter_values[] = {
    "Select Account", "Select Network", "Show 25 words", "Reset", "Back",
};

const char* settings_submenu_getter(unsigned int idx) {
    if (idx < ARRAYLEN(settings_submenu_getter_values)) {
        return settings_submenu_getter_values[idx];
    }
    return NULL;
}

void settings_back(void) { ui_menu_main_display(0); }

void settings_submenu_selector(unsigned int idx) {
    switch (idx) {
    case 0:
        settings_change_account();
        break;
    case 1:
        settings_change_network();
        break;
    case 2:
        settings_show_25_words();
        break;
    case 3:
        settings_reset();
        break;
    default:
        settings_back();
    }
}

/* --------------------------------- ABOUT UX --------------------------------- */
#define STR(x)  #x
#define XSTR(x) STR(x)

#ifdef UI_NANO_X
UX_STEP_NOCB(ux_menu_about_1_step, bnnn,
    {
        "Monero",
        "(c) Ledger SAS",
        "Spec  " XSTR(SPEC_VERSION),
        "App  " XSTR(MONERO_VERSION),
    });
#else
UX_STEP_NOCB(ux_menu_about_1a_step, bn,
    {
        "Monero",
        "(c) Ledger SAS",
    });

UX_STEP_NOCB(ux_menu_about_1b_step, nn,
    {
        "Spec  " XSTR(SPEC_VERSION),
        "App  " XSTR(MONERO_VERSION),
    });

#endif

UX_STEP_CB(ux_menu_about_2_step, pb, ui_menu_main_display(0),
    {
        &C_icon_back,
        "Back",
    });

UX_FLOW(ux_flow_about,
#ifdef UI_NANO_X
    & ux_menu_about_1_step,
#else
    & ux_menu_about_1a_step, & ux_menu_about_1b_step,
#endif
    & ux_menu_about_2_step);

void ui_menu_about_display(unsigned int value) { ux_flow_init(0, ux_flow_about, NULL); }

#undef STR
#undef XSTR

/* ---------------------------- PUBLIC ADDRESS UX ---------------------------- */
void ui_menu_pubaddr_action(unsigned int value);

#define ADDR_TYPE  G_incognito_vstate.ux_address + 108
#define ADDR_MAJOR G_incognito_vstate.ux_address + 124
#define ADDR_MINOR G_incognito_vstate.ux_address + 140
#define ADDR_IDSTR G_incognito_vstate.ux_address + 124
#define ADDR_ID    G_incognito_vstate.ux_address + 140

UX_STEP_NOCB(ux_menu_pubaddr_01_step, nn,
    {
        ADDR_TYPE,
        "Address",
    });

UX_STEP_NOCB(ux_menu_pubaddr_02_step, nn,
    {
        ADDR_MAJOR,
        ADDR_MINOR,
    });

UX_STEP_NOCB(ux_menu_pubaddr_1_step, bnnn_paging,
    { .title = "Address", .text = G_incognito_vstate.ux_address });

UX_STEP_CB(ux_menu_pubaddr_2_step, pb, ui_menu_pubaddr_action(0), { &C_icon_back, "Ok" });

UX_FLOW(ux_flow_pubaddr, &ux_menu_pubaddr_01_step, &ux_menu_pubaddr_02_step,
    &ux_menu_pubaddr_1_step, &ux_menu_pubaddr_2_step);

void ui_menu_pubaddr_action(unsigned int value) {
    if (G_incognito_vstate.disp_addr_mode) {
        incognito_io_insert_u16(SW_OK);
        incognito_io_do(IO_RETURN_AFTER_TX);
    }
    G_incognito_vstate.disp_addr_mode = 0;
    ui_menu_main_display(0);
}

/**
 *
 */
void ui_menu_any_pubaddr_display(unsigned int value, unsigned char* pub_view,
    unsigned char* pub_spend, unsigned char is_subbadress,
    unsigned char* paymanetID) {
    memset(G_incognito_vstate.ux_address, 0, sizeof(G_incognito_vstate.ux_address));

    switch (G_incognito_vstate.disp_addr_mode) {
    case 0:
    case DISP_MAIN:
        os_memmove(ADDR_TYPE, "Main", 4);
        os_memmove(ADDR_MAJOR, "Major: 0", 8);
        os_memmove(ADDR_MINOR, "minor: 0", 8);
        break;

    case DISP_SUB:
        os_memmove(ADDR_TYPE, "Sub", 3);
        snprintf(ADDR_MAJOR, 16, "Major: %d", G_incognito_vstate.disp_addr_M);
        snprintf(ADDR_MINOR, 16, "minor: %d", G_incognito_vstate.disp_addr_m);
        break;

    case DISP_INTEGRATED:
        os_memmove(ADDR_TYPE, "Integrated", 10);
        os_memmove(ADDR_IDSTR, "Payment ID", 10);
        os_memmove(ADDR_ID, G_incognito_vstate.payment_id, 16);
        break;
    }

    incognito_base58_public_key(G_incognito_vstate.ux_address, pub_view, pub_spend, is_subbadress,
        paymanetID);
    ux_layout_bnnn_paging_reset();
    ux_flow_init(0, ux_flow_pubaddr, NULL);
}

void ui_menu_pubaddr_display(unsigned int value) {
    G_incognito_vstate.disp_addr_mode = 0;
    G_incognito_vstate.disp_addr_M = 0;
    G_incognito_vstate.disp_addr_M = 0;
    ui_menu_any_pubaddr_display(value, G_incognito_vstate.A, G_incognito_vstate.B, 0, NULL);
}

#undef ADDR_TYPE
#undef ADDR_MAJOR
#undef ADDR_MINOR
#undef ADDR_IDSTR
#undef ADDR_ID


// #endif
